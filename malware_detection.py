# -*- coding: utf-8 -*-
"""malware_Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n3CMB1TowAcBQddapyEkZ4uiMmaauUjf

# **TA2 PROJECT : Malware detection using machine learning**
#program : MTech Cybersecurity
#semester-2


  #      Nandeesha G (012200300001030)


dataset reference: https://www.kaggle.com/code/maidaly/malware-detection-with-machine-learning/input
"""

import os
import pandas as pd
import numpy
import sklearn
import io
from google.colab import files
uploaded = files.upload()
dataset = pd.read_csv(io.BytesIO(uploaded['data.csv']))
print(dataset)

dataset.head()

dataset.describe()

dataset.info()

dropped_dataset = dataset.drop(['Name', 'Machine', 'TimeDateStamp', 'Malware'], axis=1)

import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
import warnings
warnings.simplefilter('ignore')

X = dropped_dataset
y = dataset['Malware']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

print("Number of used features:", X_train.shape[1])

clf = RandomForestClassifier(n_estimators=100,random_state=0,oob_score = True,max_depth = 16)
clf.fit(X_train, y_train)

y_pred = clf.predict(X_test)

print(classification_report(y_test, y_pred, target_names=['Not Malware', 'Malware']))

matrix = confusion_matrix(y_test, y_pred)
ax = sns.heatmap(matrix, annot=True, fmt="d", cmap='Blues', cbar=False, xticklabels=['Not Malware', 'Malware'], yticklabels=['Not Malware', 'Malware'])
ax.set_xlabel('Predicted Labels')
ax.set_ylabel('True Labels')

import pickle
pkl_filename = "clf.pkl"
with open(pkl_filename, 'wb') as file:
    pickle.dump(clf, file)

!pip install pefile
import pefile
from google.colab import files
uploaded = files.upload()
test_sample = list(uploaded.keys())[0]
pe = pefile.PE(test_sample)

pe.print_info()

features = []

features.extend([
    pe.DOS_HEADER.e_magic,
    pe.DOS_HEADER.e_cblp,
    pe.DOS_HEADER.e_cp,
    pe.DOS_HEADER.e_crlc,
    pe.DOS_HEADER.e_cparhdr,
    pe.DOS_HEADER.e_minalloc,
    pe.DOS_HEADER.e_maxalloc,
    pe.DOS_HEADER.e_ss,
    pe.DOS_HEADER.e_sp,
    pe.DOS_HEADER.e_csum,
    pe.DOS_HEADER.e_ip,
    pe.DOS_HEADER.e_cs,
    pe.DOS_HEADER.e_lfarlc,
    pe.DOS_HEADER.e_ovno,
    pe.DOS_HEADER.e_oemid,
    pe.DOS_HEADER.e_oeminfo,
    pe.DOS_HEADER.e_lfanew,
    pe.FILE_HEADER.NumberOfSections,
    pe.FILE_HEADER.PointerToSymbolTable,
    pe.FILE_HEADER.NumberOfSymbols,
    pe.FILE_HEADER.SizeOfOptionalHeader,
    pe.FILE_HEADER.Characteristics,
    pe.OPTIONAL_HEADER.Magic,
    pe.OPTIONAL_HEADER.MajorLinkerVersion,
    pe.OPTIONAL_HEADER.MinorLinkerVersion,
    pe.OPTIONAL_HEADER.SizeOfCode,
    pe.OPTIONAL_HEADER.SizeOfInitializedData,
    pe.OPTIONAL_HEADER.SizeOfUninitializedData,
    pe.OPTIONAL_HEADER.AddressOfEntryPoint,
    pe.OPTIONAL_HEADER.BaseOfCode,
    pe.OPTIONAL_HEADER.ImageBase,
    pe.OPTIONAL_HEADER.SectionAlignment,
    pe.OPTIONAL_HEADER.FileAlignment,
    pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
    pe.OPTIONAL_HEADER.MinorOperatingSystemVersion,
    pe.OPTIONAL_HEADER.MajorImageVersion,
    pe.OPTIONAL_HEADER.MinorImageVersion,
    pe.OPTIONAL_HEADER.MajorSubsystemVersion,
    pe.OPTIONAL_HEADER.MinorSubsystemVersion,
    pe.OPTIONAL_HEADER.SizeOfHeaders,
    pe.OPTIONAL_HEADER.CheckSum,
    pe.OPTIONAL_HEADER.SizeOfImage,
    pe.OPTIONAL_HEADER.Subsystem,
    pe.OPTIONAL_HEADER.DllCharacteristics,
    pe.OPTIONAL_HEADER.SizeOfStackReserve,
    pe.OPTIONAL_HEADER.SizeOfStackCommit,
    pe.OPTIONAL_HEADER.SizeOfHeapReserve,
    pe.OPTIONAL_HEADER.SizeOfHeapCommit,
    pe.OPTIONAL_HEADER.LoaderFlags,
    pe.OPTIONAL_HEADER.NumberOfRvaAndSizes,

])



# Extract the attributes
SuspiciousImportFunctions = len(pe.get_imphash())
features.append(SuspiciousImportFunctions)

SuspiciousNameSection = len(pe.sections)
features.append(SuspiciousNameSection)

SectionsLength = len(pe.sections)
features.append(SectionsLength)

SectionMinEntropy = min(section.get_entropy() for section in pe.sections)
features.append(SectionMinEntropy)

SectionMaxEntropy = max(section.get_entropy() for section in pe.sections)
features.append(SectionMaxEntropy)

SectionMinRawsize = min(section.SizeOfRawData for section in pe.sections)
features.append(SectionMinRawsize)

SectionMaxRawsize = max(section.SizeOfRawData for section in pe.sections)
features.append(SectionMaxRawsize)

SectionMinVirtualsize = min(section.Misc_VirtualSize for section in pe.sections)
features.append(SectionMinVirtualsize)

SectionMaxVirtualsize = max(section.Misc_VirtualSize for section in pe.sections)
features.append(SectionMaxVirtualsize)

SectionMaxPhysical = max(section.SizeOfRawData + section.PointerToRawData for section in pe.sections)
features.append(SectionMaxPhysical)

SectionMinPhysical = min(section.PointerToRawData for section in pe.sections)
features.append(SectionMinPhysical)

SectionMaxVirtual = max(section.VirtualAddress + section.Misc_VirtualSize for section in pe.sections)
features.append(SectionMaxVirtual)

SectionMinVirtual = min(section.VirtualAddress for section in pe.sections)
features.append(SectionMinVirtual)

SectionMaxPointerData = max(section.PointerToRawData for section in pe.sections)
features.append(SectionMaxPointerData)

SectionMinPointerData = min(section.PointerToRawData for section in pe.sections)
features.append(SectionMinPointerData)

SectionMaxChar = max(section.Characteristics for section in pe.sections)
features.append(SectionMaxChar)

SectionMainChar = pe.OPTIONAL_HEADER.DllCharacteristics
features.append(SectionMainChar)

DirectoryEntryImport = len(pe.DIRECTORY_ENTRY_IMPORT)
features.append(DirectoryEntryImport)

DirectoryEntryImportSize = len(pe.get_imphash())
features.append(DirectoryEntryImportSize)

DirectoryEntryExport = len(pe.DIRECTORY_ENTRY_EXPORT.symbols) if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT') else 0
features.append(DirectoryEntryExport)

ImageDirectoryEntryExport = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_EXPORT']].VirtualAddress
features.append(ImageDirectoryEntryExport)

ImageDirectoryEntryImport = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']].VirtualAddress
features.append(ImageDirectoryEntryImport)

ImageDirectoryEntryResource = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_RESOURCE']].VirtualAddress
features.append(ImageDirectoryEntryResource)

ImageDirectoryEntryException = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_EXCEPTION']].VirtualAddress
features.append(ImageDirectoryEntryException)

ImageDirectoryEntrySecurity = pe.OPTIONAL_HEADER.DATA_DIRECTORY[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_EXCEPTION']].VirtualAddress
features.append(ImageDirectoryEntrySecurity)


print(len(features))


print(features)

import numpy as np
features=np.reshape(features,(1,-1))


# Load the trained model
with open('clf.pkl', 'rb') as f:
    clf = pickle.load(f)
#dropped_test = features.drop(['Machine', 'TimeDateStamp'])
# Perform predictions on the test dataset
predictions = clf.predict(features)

# Print the predictions
for i, prediction in enumerate(predictions):
    if prediction == 1:
        print(f"Sample {i+1}: Malicious")
    else:
        print(f"Sample {i+1}: Benign")